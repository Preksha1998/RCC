*******************************************************************************************************************************************
*******************************************************************************************************************************************
Name: Shaikh Faizan
Subject: Data Structure - DS
Roll no: 25
Class: MCA-3
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Tree:
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q1)

Perform following operations on recursive binary search tree:

A. Insert
B. Delete
C. Display(Pre-order,In-order,Post-order traversal)
D. Find maximum value
E. Find minimum value
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
struct node
{
	int v;
	struct node *left;
	struct node *right;
};
typedef struct node n;
void insert(n *root,n *nn)
{
	if(nn->v<root->v)
	{
		if(root->left!=NULL)
		{
			insert(root->left,nn);
		}
		else
		{
			root->left=nn;
		}
	}
	else if(nn->v>root->v)
	{
		if(root->right!=NULL)
		{
			insert(root->right,nn);
		}
		else
		{
			root->right=nn;
		}
	}
}
void min(n* root)
{
	if(root!=NULL)
	{
		printf("%ld ",root->v);
		if(root->left!=NULL)
		{
			min(root->left);
		}
		else
		{	
			printf("\nMinimum Value: %ld",root->v);
		}
	}
}
void max(n* root)
{
	if(root!=NULL)
	{
		printf("%ld ",root->v);
		if(root->right!=NULL)
		{
			max(root->right);
		}
		else
		{	
			printf("\nMaximum Value: %ld",root->v);
		}
	}
}
n* mx(n* root)
{
	if(root!=NULL)
	{
		if(root->right!=NULL)
		{
			mx(root->right);
		}
		else
		{	
			return root;
		}
	}
}
void displaypre(n* root)
{
	if(root!=NULL)
	{
	printf("%ld ",root->v);
	displaypre(root->left);
	displaypre(root->right);
	}
}
void displayin(n* root)
{
	if(root!=NULL)
	{
	displayin(root->left);
	printf("%ld ",root->v);
	displayin(root->right);
	}
}
void displaypost(n* root)
{
	if(root!=NULL)
	{
	displaypost(root->left);
	displaypost(root->right);
	printf("%ld ",root->v);
	}
}
n *deleten(n *root,int vv)
{
	n *t=NULL;
	if(vv<root->v)
	{
		root->left=deleten(root->left,vv);
	}
	else if(vv>root->v)
	{
		root->right=deleten(root->right,vv);
	}
	else
	{
		if(root->left==NULL)
		{
			t=root->right;
			free(root);
			return t;
		}
		else if(root->right==NULL)
		{
			t=root->left;
			free(root);
			return t;
		}
		t=mx(root->left);
		root->v=t->v;
		root->left=deleten(root->left,t->v);
	}
	return root;
}
void main()
{
	n *nn=NULL,*root=NULL;
	int vv;
	char c=49;
	while(c>=49 && c<=55)
	{
		printf("\nEnter 1 if you want to insert in a node in the Tree: ");
		printf("\nEnter 2 for displaying the data in  the tree in format of pre-order traversal: ");
		printf("\nEnter 3 for displaying the data in  the tree in format of In-order traversal: ");
		printf("\nEnter 4 for displaying the data in  the tree in format of post-order traversal: ");
		printf("\nEnter 5 for displaying minimum value: ");
		printf("\nEnter 6 for displaying maximum value: ");
		printf("\nEnter 7 for deleting a node: ");
		printf("\nPress any other key to exit the program: ");
		scanf(" %c",&c);
		if(c==49)
		{
			nn=(n*)malloc(sizeof(n));
			printf("\nEnter the value of the node that you want to enter in the tree: ");
			scanf(" %ld",&nn->v);
			nn->left=NULL;
			nn->right=NULL;
			if(root==NULL)
			{
				root=nn;
			}
			else
			{
				insert(root,nn);
			}
		}
		else if(c==50)
		{
			displaypre(root);
		}
		else if(c==51)
		{
			displayin(root);
		}
		else if(c==52)
		{
			displaypost(root);
		}
		else if(c==53)
		{
			min(root);
		}
		else if(c==54)
		{
			max(root);
		}
		else if(c==55)
		{
			printf("\nEnter the value of the node that you want to delete: ");
			scanf(" %ld",&vv);
			deleten(root,vv);
		}
	}
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 29

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 48

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 12

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 5

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 87

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 62

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 51

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 33

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 39

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 31

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 8

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
29 12 5 8 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 3
5 8 12 29 31 33 39 48 51 62 87
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 4
8 5 12 31 39 33 51 62 87 48 29
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
29 12 5 8 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 7

Enter the value of the node that you want to delete: 8

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
29 12 5 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 7

Enter the value of the node that you want to delete: 5

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
29 12 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 7

Enter the value of the node that you want to delete: 29

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
12 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 5
12
Minimum Value: 12
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 6
12 48 87
Maximum Value: 87
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 2
12 48 33 31 39 87 62 51
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 3
12 31 33 39 48 51 62 87
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program: 4
31 39 33 51 62 87 48 12
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Enter 7 for deleting a node:
Press any other key to exit the program:
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q2)

Perform following operations on non-recursive binary search tree:

A. Insert
B. Delete
C. Display(Pre-order,In-order,Post-order traversal)
D. Find maximum value
E. Find minimum value
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
struct node
{
	int v;
	struct node *left;
	struct node *right;
};
typedef struct node n;
void insert(n *root,n *nn)
{
	if(nn->v<root->v)
	{
		if(root->left!=NULL)
		{
			insert(root->left,nn);
		}
		else
		{
			root->left=nn;
		}
	}
	else if(nn->v>root->v)
	{
		if(root->right!=NULL)
		{
			insert(root->right,nn);
		}
		else
		{
			root->right=nn;
		}
	}
}
void min(n* root)
{
	if(root!=NULL)
	{
		printf("%ld ",root->v);
		if(root->left!=NULL)
		{
			min(root->left);
		}
		else
		{	
			printf("\nMinimum Value: %ld",root->v);
		}
	}
}
void max(n* root)
{
	if(root!=NULL)
	{
		printf("%ld ",root->v);
		if(root->right!=NULL)
		{
			max(root->right);
		}
		else
		{	
			printf("\nMaximum Value: %ld",root->v);
		}
	}
}
void displaypre(n* root)
{
	if(root!=NULL)
	{
	printf("%ld ",root->v);
	displaypre(root->left);
	displaypre(root->right);
	}
}
void displayin(n* root)
{
	if(root!=NULL)
	{
	displayin(root->left);
	printf("%ld ",root->v);
	displayin(root->right);
	}
}
void displaypost(n* root)
{
	if(root!=NULL)
	{
	displaypost(root->left);
	displaypost(root->right);
	printf("%ld ",root->v);
	}
}
void main()
{
	n *nn=NULL,*root=NULL;
	char c=49;
	while(c==49 || c==50 || c==51 ||c==52|| c==53 || c==54)
	{
		printf("\nEnter 1 if you want to insert in a node in the Tree: ");
		printf("\nEnter 2 for displaying the data in  the tree in format of pre-order traversal: ");
		printf("\nEnter 3 for displaying the data in  the tree in format of In-order traversal: ");
		printf("\nEnter 4 for displaying the data in  the tree in format of post-order traversal: ");
		printf("\nEnter 5 for displaying minimum value: ");
		printf("\nEnter 6 for displaying maximum value: ");
		printf("\nPress any other key to exit the program: ");
		scanf(" %c",&c);
		if(c==49)
		{
			nn=(n*)malloc(sizeof(n));
			printf("\nEnter the value of the node that you want to enter in the tree: ");
			scanf(" %ld",&nn->v);
			nn->left=NULL;
			nn->right=NULL;
			if(root==NULL)
			{
				root=nn;
			}
			else
			{
				insert(root,nn);
			}
		}
		else if(c==50)
		{
			displaypre(root);
		}
		else if(c==51)
		{
			displayin(root);
		}
		else if(c==52)
		{
			displaypost(root);
		}
		else if(c==53)
		{
			min(root);
		}
		else if(c==54)
		{
			max(root);
		}
	}
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 20

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 10

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 23

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 19

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 2
20 10 19 23
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 3
10 19 20 23
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 4
19 10 23 20
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 12

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 13

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 14

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 34

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 35

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 1

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 36

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 40

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 1

Enter the value of the node that you want to enter in the tree: 16

Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 2
20 10 1 19 12 13 14 16 23 34 35 36 40
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 3
1 10 12 13 14 16 19 20 23 34 35 36 40
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 4
1 16 14 13 12 19 10 40 36 35 34 23 20
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 3
1 10 12 13 14 16 19 20 23 34 35 36 40
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 2
20 10 1 19 12 13 14 16 23 34 35 36 40
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program: 4
1 16 14 13 12 19 10 40 36 35 34 23 20
Enter 1 if you want to insert in a node in the Tree:
Enter 2 for displaying the data in  the tree in format of pre-order traversal:
Enter 3 for displaying the data in  the tree in format of In-order traversal:
Enter 4 for displaying the data in  the tree in format of post-order traversal:

Enter 5 for displaying minimum value:
Enter 6 for displaying maximum value:
Press any other key to exit the program:
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q3)

Write a program to create an expression tree and perform traversals to display expression.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<stdlib.h>
struct node
{
	char v;
	struct node *left;
	struct node *right;
};
int top = -1;
typedef struct node n;
void push(n *s[], n *nn)
{
	top++;
	s[top] = nn;
}
n* pop(n *s[])
{
	n *vv=NULL;
	vv = s[top];
	top--;
	return vv;
}
void pre(n* root)
{
	if (root != NULL)
	{
		printf("%c", root->v);
		pre(root->left);
		pre(root->right);
	}
}
void in(n* root)
{
	if (root != NULL)
	{
		in(root->left);
		printf("%c", root->v);
		in(root->right);
	}
}
void post(n* root)
{
	if (root != NULL)
	{
		post(root->left);
		post(root->right);
		printf("%c", root->v);
	}
}
void main()
{
	int k = 0, l=0;
	char fs[50];
	n *temp, *stemp = NULL, *s[20], *root = NULL;
	printf("\nEnter postfix expression you want to convert into expression tree: ");
	scanf(" %s",fs,sizeof(fs));
	l = strlen(fs);
	while (k <= (l - 1))
	{
		if (stemp != NULL)
		{
			push(s,stemp);
			stemp = NULL;
		}
		temp = (n*)malloc(sizeof(n));
		temp->left = NULL;
		temp->right = NULL;
		temp->v = fs[k];
		if (fs[k] >='a' && fs[k] <= 'z')
		{
			push(s, temp);
		}
		else
		{
			temp->right = pop(s);
			temp->left = pop(s);
			stemp = temp;
		}
		k++;
	}
	root = temp;
	printf("\n");
	printf("\nPre-order Traversal of tree:- ");
	pre(root);
	printf("\nIn-order Traversal of tree:- ");
	in(root);
	printf("\nPost-order Traversal of tree:- ");
	post(root);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter postfix expression you want to convert into expression tree: ab+c*


Pre-order Traversal of tree:- *+abc
In-order Traversal of tree:- a+b*c
Post-order Traversal of tree:- ab+c*
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Algorithms:-
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q1)

Write a program to sort a list of numbers using Bubble Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void bs(int a[],int s)
{
	int i,j,flag=0,temp;
	for(i=0;i<s-1;i++)
	{
		flag=0;
		for(j=0;j<s-i-1;j++)
		{
			if(a[j]>a[j+1])
			{
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
				flag=1;
			}
		}
		if(flag==0)
		{
			break;
		}
	}
}
void display(int a[],int s)
{
	int i;
	printf("\nArray: ");
	for(i=0; i<s; i++)
	{
		printf("%ld ",a[i]);
	}
}
void main()
{
	int a[30],s,i;
	printf("\nEnter size: ");
	scanf(" %ld",&s);
	printf("\nEnter elements in the array: ");
	for(i=0;i<s;i++)
	{
	scanf(" %ld",&a[i]);
	}
	display(a,s);
	bs(a,s);
	display(a,s);
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size: 5

Enter elements in the array: 10
5
3
4
7

Array: 10 5 3 4 7
Array: 3 4 5 7 10
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q2)

Write a program to sort a list of numbers using Selection Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void display(int a[],int s)
{
	int i;
	printf("\nArray: ");
	for(i=0; i<s; i++)
	{
		printf("%d ",a[i]);
	}
}
void selectionsort(int a[],int s)
{
	int i=0,j,flag=0,min,l;

	for(i=0;i<s-1;i++)
	{
		min = a[i];
		l = i;

		for(j=i+1;j<s;j++)
		{
			if(min > a[j])
			{
				min = a[j];
				l = j;
			}
		}

		a[l] = a[i];
		a[i] = min;
	}
}

void main()
{
	int a[30],s,i;
	printf("\nEnter size: ");
	scanf(" %d",&s);
	printf("\nEnter elements in the array: ");
	for(i=0;i<s;i++)
	{
	scanf(" %d",&a[i]);
	}
	display(a,s);
	selectionsort(a,s);
	display(a,s);
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size: 5

Enter elements in the array: 10
5
4
1
2

Array: 10 5 4 1 2
Array: 1 2 4 5 10
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q3)

Write a program to sort a list of numbers using Insertion Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void display(int a[],int s)
{
	int i;
	printf("\nArray: ");
	for(i=0; i<s; i++)
	{
		printf("%d ",a[i]);
	}
}
void insertionsort(int a[],int s)
{
	int i=0,j,flag=0,min,l;

	for(i=1;i<s;i++)
	{
		j=i-1;
		min=a[i];
		while(j>=0 && min<a[j])
		{
			a[j+1]=a[j];
			j--;
		}
		a[j+1]=min;
	}
}

void main()
{
	int a[30],s,i;
	printf("\nEnter size: ");
	scanf(" %d",&s);
	printf("\nEnter elements in the array: ");
	for(i=0;i<s;i++)
	{
	scanf(" %d",&a[i]);
	}
	display(a,s);
	insertionsort(a,s);
	display(a,s);
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size: 5

Enter elements in the array: 10
5
4
8
1

Array: 10 5 4 8 1
Array: 1 4 5 8 10
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q4)

Write a program to search for a value from a list using Linear Search.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int a[],int s)
{
	int i;
	printf("\nEnter  value of elements in the array: ");
	for(i=0; i<s; i++)
	{
		printf("\nEnter value of element at index-%ld: ",i);
		scanf(" %ld",&a[i]);
	}
}
void display(int a[],int s)
{
	int i;
	printf("\nElements in the array  are as follows: ");
	for(i=0; i<s; i++)
	{
		printf("%ld ",a[i]);
	}
}
void lsearch(int a[],int s)
{
	int i,v,f=0;
	printf("\nEnter the element that you want to search in the array: ");
	scanf(" %ld",&v);
	for(i=0; i<s; i++)
	{
		if(a[i]==v)
		{
			printf("\nElement %ld found at index-%ld!",a[i],i);
			f=1;
		}
	}
	if(f==0)
	{
		printf("\nElement %ld not found in the array!",v);
	}
}
void main()
{
	int s,i,a[20];
	printf("\nEnter size of the array: ");
	scanf(" %ld",&s);
	insert(a,s);
	display(a,s);
	lsearch(a,s);
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************
OUTPUT-1:


Enter size of the array: 5

Enter  value of elements in the array:
Enter value of element at index-0: 10

Enter value of element at index-1: 20

Enter value of element at index-2: 30

Enter value of element at index-3: 40

Enter value of element at index-4: 50

Elements in the array  are as follows: 10 20 30 40 50
Enter the element that you want to search in the array: 60

Element 60 not found in the array!

OUTPUT-2:


Enter size of the array: 5

Enter  value of elements in the array:
Enter value of element at index-0: 10

Enter value of element at index-1: 20

Enter value of element at index-2: 30

Enter value of element at index-3: 40

Enter value of element at index-4: 50

Elements in the array  are as follows: 10 20 30 40 50
Enter the element that you want to search in the array: 20

Element 20 found at index-1!
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q5)

Write a program to search for a value from a list using Binary Search.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int a[],int s)
{
	int i;
	printf("\nEnter  value of elements in the array: ");
	for(i=0; i<s; i++)
	{
		printf("\nEnter value of element at index-%ld: ",i);
		scanf(" %ld",&a[i]);
	}
}
void display(int a[],int s)
{
	int i;
	printf("\nElements in the array  are as follows: ");
	for(i=0; i<s; i++)
	{
		printf("%ld ",a[i]);
	}
}
void bsearch(int a[],int s)
{
	int i,v,start=0,end=s-1,mid=0,f=0;
	mid=(start+end)/2;
	printf("\nEnter the element that you want to search in the array: ");
	scanf(" %ld",&v);
	while(start<=end)
	{
		if(v<a[mid])
		{
			mid=(start+end)/2;
			end=mid-1;
		}
		else if(v>a[mid])
		{
			mid=(start+end)/2;
			start=mid+1;
		}
		else
		{
			printf("\nElement %ld found at index-%ld!",v,mid);
			f=1;
			break;
		}
	}
	if(f==0)
	{
		printf("\nElement %ld not found in the array!",v);
	}
}
void main()
{
	int s,i,a[20];
	printf("\nEnter size of the array: ");
	scanf(" %ld",&s);
	insert(a,s);
	display(a,s);
	bsearch(a,s);
	getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************
OUTPUT-1:


Enter size of the array: 5

Enter  value of elements in the array:
Enter value of element at index-0: 10

Enter value of element at index-1: 20

Enter value of element at index-2: 30

Enter value of element at index-3: 40

Enter value of element at index-4: 50

Elements in the array  are as follows: 10 20 30 40 50
Enter the element that you want to search in the array: 60

Element 60 not found in the array!

OUTPUT-2:


Enter size of the array: 5

Enter  value of elements in the array:
Enter value of element at index-0: 10

Enter value of element at index-1: 20

Enter value of element at index-2: 30

Enter value of element at index-3: 40

Enter value of element at index-4: 50

Elements in the array  are as follows: 10 20 30 40 50
Enter the element that you want to search in the array: 40

Element 40 found at index-3!
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q6)

Write a program to sort a list of numbers using Radix Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<math.h>
#include<stdlib.h>
struct node
{
	int v;
	struct node *next;
};
typedef struct node nn;
int getmax(nn *head)
{
	int max=head->v;
	nn* temp =head->next;
	while (temp != NULL)
	{
		if (max < temp->v)
		{
			max = temp->v;
		}
		temp = temp->next;
	}
	return max;
}
nn* insert(nn* head)
{
	char c = 49;
	nn *temp = NULL,*oldnode=NULL;
	printf("\nEnter elements in linkedlist: ");
	while (c == 49)
	{
		temp = (nn*)malloc(sizeof(temp));
		printf("\nEnter element: ");
		scanf_s(" %ld",&temp->v);
		temp->next = NULL;
		if (head == NULL)
		{
			head = temp;
		}
		else
		{
			oldnode->next = temp;
		}
		oldnode = temp;
		printf("\nEnter 1 for another value: ");
		scanf_s(" %c", &c);
	}
	return head;
}
void display(nn* head)
{
	nn *temp = NULL;
	temp = head;
	printf("\nList:");
	while (temp != NULL)
	{
		printf(" %ld", temp->v);
		temp = temp->next;
	}
}
nn* joinnext(nn* arr[])
{
	int i = 0;
	nn *temp = NULL, *last = NULL,*head=NULL;
	for (i = 0; i < 10; i++)
	{
		if (arr[i] != NULL)
		{
			temp = arr[i];
			if (head == NULL)
			{
				head = temp;
			}
			if (last != NULL)
			{
				last->next = temp;
			}
			while (temp->next != NULL)
			{
				temp = temp->next;
			}
			last = temp;
		}
	}
	last->next = NULL;
	//printf("\nJoinnext: ");
	//display(head);
	return head;
}
void radixsort(nn *head)
{
	int max=getmax(head);
	int i,r,b=10,tn=0,j;
	nn *temp = NULL, *arr[20] = { NULL },*atemp=NULL;
	for (i = max; i > 0; i = i / 10)
	{
		if (i == max)
		{
			temp = head;
			while (temp != NULL)
			{
				r = temp->v % 10;
				if (arr[r] == NULL)
				{
					arr[r] = temp;
					temp = temp->next;
					arr[r]->next = NULL;
				}
				else
				{
					atemp = arr[r];
					while (atemp->next != NULL)
					{
						atemp = atemp->next;
					}
					atemp->next = temp;
					atemp = atemp->next;
					temp = temp->next;
					atemp->next = NULL;
				}
			}
			head=joinnext(arr);
		}
		else
		{
			temp = head;
			for (j = 0; j < 10; j++)
			{
				arr[j] = NULL;
			}
			while (temp != NULL)
			{
				tn = temp->v/b;
				r = tn % 10;
				if (arr[r] == NULL)
				{
					arr[r] = temp;
					temp = temp->next;
					arr[r]->next = NULL;
				}
				else
				{
					atemp = arr[r];
					while (atemp->next != NULL)
					{
						atemp = atemp->next;
					}
					atemp->next = temp;
					atemp = atemp->next;
					temp = temp->next;
					atemp->next = NULL;
				}
			}
			head = joinnext(arr);
			b = b * 10;
		}
	}
	printf("\nAfter Sorting: ");
	display(head);
}
void main()
{
	nn *head = NULL;
	head = insert(head);
	display(head);
	radixsort(head);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter elements in linkedlist:
Enter element: 34

Enter 1 for another value: 1

Enter element: 32

Enter 1 for another value: 1

Enter element: 11

Enter 1 for another value: 1

Enter element: 9

Enter 1 for another value: 1

Enter element: 74

Enter 1 for another value: 1

Enter element: 46

Enter 1 for another value: 1

Enter element: 89

Enter 1 for another value: 1

Enter element: 112

Enter 1 for another value: 1

Enter element: 140

Enter 1 for another value: 1

Enter element: 59

Enter 1 for another value: 2

List: 34 32 11 9 74 46 89 112 140 59
After Sorting:
List: 9 11 32 34 46 59 74 89 112 140
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q7)

Write a program to sort a list of numbers using Heap Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int arr[],int n)
{
	int i;
	printf("\nEnter elements of array: ");
	for(i = 0; i < n; i++)
	{
		scanf_s(" %ld", &arr[i]);
	}
}
void display(int arr[], int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		printf(" %ld",arr[i]);
	}
}
void swap(int *a, int *b)
{
	int t=*a;
	*a = *b;
	*b = t;
}
void cheap(int arr[],int n,int i)
{
	int largest=i, l=2*i+1, r=2*i+2;
	if (l<n && arr[l]>arr[largest])
	{
		largest = l;
	}
	if (r<n && arr[r]>arr[largest])
	{
		largest = r;
	}
	if (largest != i)
	{
		swap(&arr[i], &arr[largest]);
		cheap(arr, n, largest);
	}
}
void heapsort(int arr[], int n)
{
	int i = 0;
	for (i = n/2 - 1; i >= 0; i--)
	{
		cheap(arr, n, i);
	}
	for (i = n - 1; i >= 0; i--)
	{
		swap(&arr[0], &arr[i]);
		cheap(arr, i, 0);
	}
}
void main()
{
	int arr[20],n;
	printf("\nEnter size of Array: ");
	scanf_s(" %ld", &n);
	insert(arr, n);
	printf("\nElements of Array:");
	display(arr, n);
	heapsort(arr, n);
	printf("\nElements of Array after Heapsort:");
	display(arr, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size of Array: 10

Enter elements of array: 34
32 11 9 74 46 89 112 140 59

Elements of Array: 34 32 11 9 74 46 89 112 140 59
Elements of Array after Heapsort: 9 11 32 34 46 59 74 89 112 140
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q8)

Write a program to sort a list of numbers using Shell Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int arr[], int n)
{
	int i;
	printf("\nEnter elements of array: ");
	for (i = 0; i < n; i++)
	{
		scanf_s(" %ld", &arr[i]);
	}
}
void display(int arr[], int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		printf(" %ld", arr[i]);
	}
}
void shellsort(int arr[], int n)
{
	int i, j, gap, temp;
	for (gap = n / 2; gap>0; gap = gap / 2)
	{
		for (i = gap; i < n; i++)
		{
			temp = arr[i];
			for (j = i; j >= gap && arr[j - gap] >temp; j = j - gap)
			{
				arr[j] = arr[j - gap];
			}
			arr[j] = temp;
		}
	}
}
void main()
{
	int arr[20], n;
	printf("\nEnter size of Array: ");
	scanf_s(" %ld", &n);
	insert(arr, n);
	printf("\nElements of Array:");
	display(arr, n);
	shellsort(arr, n);
	printf("\nElements of Array after Shellsort:");
	display(arr, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size of Array: 10

Enter elements of array: 34 32 11 9 74 46 89 112 140 59

Elements of Array: 34 32 11 9 74 46 89 112 140 59
Elements of Array after Shellsort: 9 11 32 34 46 59 74 89 112 140
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q9)

Write a program to sort a list of numbers using Quick Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int arr[], int n)
{
	int i;
	printf("\nEnter elements of array: ");
	for (i = 0; i < n; i++)
	{
		scanf_s(" %ld", &arr[i]);
	}
}
void display(int arr[], int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		printf(" %ld", arr[i]);
	}
}
void swap(int *a, int *b)
{
	int t;
	t = *a;
	*a = *b;
	*b = t;
}
int partition(int arr[], int low, int high)
{
	int pivot = arr[high],i,j;
	i = low - 1;
	for (j = low; j < high; j++)
	{
		if (arr[j] <= pivot)
		{
			i++;
			swap(&arr[i], &arr[j]);
		}
	}
	swap(&arr[i + 1], &arr[high]);
	return (i + 1);
}
void quicksort(int arr[], int low,int high)
{
	if (low < high)
	{
		int pi = partition(arr, low, high);
		quicksort(arr, low, pi - 1);
		quicksort(arr, pi + 1, high);
	}
}
void main()
{
	int arr[20], n,low,high;
	printf("\nEnter size of Array: ");
	scanf_s(" %ld", &n);
	insert(arr, n);
	printf("\nElements of Array:");
	display(arr, n);
	low = 0;
	high = n - 1;
	quicksort(arr,low,high);
	printf("\nElements of Array after Quicksort:");
	display(arr, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter size of Array: 10

Enter elements of array: 34
32 11 9 74 46 89 112 140 59

Elements of Array: 34 32 11 9 74 46 89 112 140 59
Elements of Array after Quicksort: 9 11 32 34 46 59 74 89 112 140
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q10)

Write a program to sort a list of numbers using Merge Sort.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
void insert(int arr[], int n)
{
	int i;
	printf("\nEnter elements in array: ");
	for (i = 0; i < n; i++)
	{
		scanf_s(" %ld", &arr[i]);
	}
}
void display(int arr[], int n)
{
	printf("\nElements in array: ");
	for (int i = 0; i < n; i++)
	{
		printf("%ld ", arr[i]);
	}
}

void merge(int arr[], int l, int m, int r)
{
	int n1, n2,L[20],R[20],i,j,k;
	n1 = m - l+1;
	n2 = r - m;
	for (i = 0; i < n1; i++)
	{
		L[i] = arr[l+i];
	}
	for (j = 0; j < n2; j++)
	{
		R[j] = arr[m + 1 + j];
	}
	i = 0;
	j = 0;
	k = l;
	while (i < n1 && j < n2)
	{
		if (L[i] < R[j])
		{
			arr[k] = L[i];
			i++;
		}
		else if (R[j] < L[i])
		{
			arr[k] = R[j];
			j++;
		}
		else
		{
			arr[k] = R[j];
			j++;
			k++;
			arr[k] = L[i];
			i++;
		}
		k++;
	}
	while (i < n1)
	{
		arr[k] = L[i];
		i++;
		k++;
	}
	while (j< n2)
	{
		arr[k] = R[j];
		j++;
		k++;
	}
}

void mergesort(int arr[], int l, int r)
{
	int m;
	if (l < r)
	{
		m = (l+r) / 2;
		mergesort(arr, l, m);
		mergesort(arr, m + 1, r);
		merge(arr, l, m, r);
	}
}

void main()
{
	int arr[20], n,l,r;
	printf("\nEnter number of elements in array: ");
	scanf_s(" %ld", &n);
	insert(arr, n);
	display(arr, n);
	l = 0;
	r = n - 1;
	mergesort(arr, l, r);
	display(arr, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of elements in array: 8

Enter elements in array: 89 95 26 32 8 71 11 45

Elements in array: 89 95 26 32 8 71 11 45
Elements in array: 8 11 26 32 45 71 89 95
*******************************************************************************************************************************************
*******************************************************************************************************************************************
GRAPH:-
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q1)

Write a program to find the shortest path between two vertices in an unweighted directed graph.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct alist
{
	int v;
	struct alist *next;
};
typedef struct alist alist;
struct gtable
{
	int k, v, dv, pv;
};
typedef struct gtable gtable;
int top = -1;
int a[20];
void push(int vv)
{
	if (top < 20-1)
	{
		top++;
		a[top] = vv;
	}
	else
	{
		printf("\nStack is Full!");
	}
}
int pop()
{
	int vv;
	if (top != -1)
	{
		vv=a[top];
		top--;
	}
	else
	{
		vv = -1;
	}
	return vv;
}

void insert(alist al[], int n, gtable gt[])
{
	char c = 49;
	int x;
	alist *temp = NULL,*t=NULL;
	int i,flag=0;
	for (i = 0; i < n; i++)
	{
		printf("\nEnter vertice number: ");
		scanf_s(" %ld", &al[i].v);
		al[i].next = NULL;
		x = al[i].v;
		gt[i].v=x;
		printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ",al[i].v);
		scanf_s(" %c",&c);
		flag = 0;
		while (c == 49)
		{
			temp = (alist*)malloc(sizeof(alist));
			printf("\nEnter vertice pointed by vertice-%ld: ", al[i].v);
			scanf_s(" %ld", &temp->v);
			temp->next = NULL;
			if (flag == 0)
			{
				al[i].next = temp;
				t = temp;
				flag = 1;
			}
			else
			{
				t->next = temp;
				t = temp;
			}
			printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ",al[i].v);
			scanf_s(" %c",&c);
		}
	}
}
void displayal(alist al[], int n)
{
	alist *t = NULL;
	printf("\nAdjancency list:");
	for(int i = 0; i < n; i++)
	{
		printf("\n%ld", al[i].v);
		t = al[i].next;
		while (t!= NULL)
		{
			printf("->%ld",t->v);
			t = t->next;
		}
	}
}
void ctable(alist al[],int n,gtable gt[],int sn)
{
	int i,j,v=0;
	alist *temp = NULL;
	displayal(al, n);
	for (i = 0; i < n; i++)
	{
			gt[i].k = 0;
			gt[i].dv =-1;
			gt[i].pv =-1;
	}
	gt[sn - 1].dv = 0;
	gt[sn - 1].pv = 0;
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
		{
			if (gt[j].k == 0 && gt[j].dv==i)
			{
				gt[j].k = 1;
				temp=al[j].next;				
				while (temp != NULL)
				{
					v =(temp->v)-1;
					if (gt[v].dv==-1)
					{
						gt[v].dv = i+1;
						gt[v].pv =al[j].v;
					}
					temp = temp->next;
				}
			}
		}
	}
}
void displayt(gtable gt[], int n)
{
	int i;
	printf("\nTable: ");
	for (i = 0; i < n; i++)
	{
		printf("\nv: %ld %ld %ld %ld", gt[i].v, gt[i].k, gt[i].dv, gt[i].pv);
	}
}
void shortpath(gtable gt[], int n, alist al[], int sn)
{
	int sv, dv,v,dd,tv,vv;
	alist *temp = NULL;
	printf("\nEnter destination vertice: ");
	scanf_s(" %ld", &dv);
	push(dv);
	v=(int)gt[(dv - 1)].pv;
	dd= gt[(dv - 1)].dv;
	/*temp = al[v - 1].next;
	while (temp != NULL)
	{
		if (temp->v == dv)
		{
			dd = temp->w;
		}
		temp = temp->next;
	}*/
	while(v!=dv)
	{
		push(v);
		tv = v;
		v = gt[v - 1].pv;
		if (v == 0)
		{
			break;
		}
		/*else
		{
			temp = al[v - 1].next;
			while (temp != NULL)
			{
				if (temp->v == tv)
				{
					dd = dd + temp->w;
					break;
				}
				temp = temp->next;
			}
		}*/
	}
	printf("\nPath: v%ld", pop());
	vv =pop();
	while (vv != -1)
	{
		printf("->v%ld", vv);
		vv = pop();
	}
	printf("\nShortest path from v%ld to v%ld is: %ld", sn, dv, dd);
}
void main()
{
	alist *al =NULL;
	gtable *gt = NULL;
	int n, sn;
	char c = 49;
	printf("\nEnter number of vertices in the graph: ");
	scanf_s(" %ld", &n);
	al = (alist*)calloc(n, sizeof(alist));
	gt = (gtable*)calloc(n, sizeof(gtable));
	insert(al, n, gt);
	displayal(al,n);
	printf("\nEnter Starting node: ");
	scanf_s(" %ld", &sn);
	ctable(al, n, gt, sn);
	displayt(gt, n);
	while(c==49)
	{
				shortpath(gt, n, al,sn);
				printf("\nEnter 1 for choosing another path: ");
				scanf_s(" %c", &c);
	}
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of vertices in the graph: 7

Enter vertice number: 1

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 2

Enter 1 if vertice-1 is pointing to another vertices: 2

Enter vertice number: 2

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 3

Enter 1 if vertice-2 is pointing to another vertices: 2

Enter vertice number: 3

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 1

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 4

Enter 1 if vertice-3 is pointing to another vertices: 2

Enter vertice number: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 2

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 6

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 7

Enter 1 if vertice-4 is pointing to another vertices: 2

Enter vertice number: 5

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 3

Enter 1 if vertice-5 is pointing to another vertices: 2

Enter vertice number: 6

Enter 1 if vertice-6 is pointing to another vertices: 1

Enter vertice pointed by vertice-6: 5

Enter 1 if vertice-6 is pointing to another vertices: 2

Enter vertice number: 7

Enter 1 if vertice-7 is pointing to another vertices: 1

Enter vertice pointed by vertice-7: 6

Enter 1 if vertice-7 is pointing to another vertices: 2

Adjancency list:
1->2
2->3
3->1->4
4->2->6->7
5->3
6->5
7->6
Enter Starting node: 1

Adjancency list:
1->2
2->3
3->1->4
4->2->6->7
5->3
6->5
7->6
Table:
v: 1 1 0 0
v: 2 1 1 1
v: 3 1 2 2
v: 4 1 3 3
v: 5 1 5 6
v: 6 1 4 4
v: 7 1 4 4
Enter destination vertice: 6

Path: v1->v2->v3->v4->v6
Shortest path from v1 to v6 is: 4
Enter 1 for choosing another path: 1

Enter destination vertice: 4

Path: v1->v2->v3->v4
Shortest path from v1 to v4 is: 3
Enter 1 for choosing another path: 1

Enter destination vertice: 5

Path: v1->v2->v3->v4->v6->v5
Shortest path from v1 to v5 is: 5
Enter 1 for choosing another path: 1

Enter destination vertice: 3

Path: v1->v2->v3
Shortest path from v1 to v3 is: 2
Enter 1 for choosing another path:
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q2)

Write a program to find the shortest path between two vertices in a
weighted directed graph.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct alist
{
	int v;
	int w;
	struct alist *next;
};
typedef struct alist alist;
struct gtable
{
	int k, v, dv, pv;
};
typedef struct gtable gtable;
int top = -1;
int a[20];
void push(int vv)
{
	if (top < 20-1)
	{
		top++;
		a[top] = vv;
	}
	else
	{
		printf("\nStack is Full!");
	}
}
int pop()
{
	int vv;
	if (top != -1)
	{
		vv=a[top];
		top--;
	}
	else
	{
		vv = -1;
	}
	return vv;
}
void insert(alist al[], int n, gtable gt[])
{
	char c = 49;
	int x;
	alist *temp = NULL, *t = NULL;
	int i, flag = 0;
	for (i = 0; i < n; i++)
	{
		printf("\nEnter vertice number: ");
		scanf_s(" %ld", &al[i].v);
		al[i].w = -1;
		al[i].next = NULL;
		x = al[i].v;
		gt[i].v = x;
		printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
		scanf_s(" %c", &c);
		flag = 0;
		while (c == 49)
		{
			temp = (alist*)malloc(sizeof(alist));
			printf("\nEnter vertice pointed by vertice-%ld: ", al[i].v);
			scanf_s(" %ld", &temp->v);
			printf("\nEnter distance between v%ld & v%ld: ", al[i].v,temp->v);
			scanf_s(" %ld", &temp->w);
			temp->next = NULL;
			if (flag == 0)
			{
				al[i].next = temp;
				t = temp;
				flag = 1;
			}
			else
			{
				t->next = temp;
				t = temp;
			}
			printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
			scanf_s(" %c", &c);
		}
	}
}
void displayal(alist al[], int n)
{
	alist *t = NULL;
	printf("\nAdjancency list:");
	for (int i = 0; i < n; i++)
	{
		printf("\nv%ld", al[i].v);
		t = al[i].next;
		while (t != NULL)
		{
			printf("->v%ld d: %ld", t->v,t->w);
			t = t->next;
		}
	}
}
void ctable(alist al[], int n, gtable gt[], int sn)
{
	int i, j, v = 0,min=0,tmin=0;
	alist *temp = NULL;
	for (i = 0; i < n; i++)
	{
		gt[i].k = 0;
		gt[i].dv = -1;
		gt[i].pv = -1;
	}
	gt[sn - 1].dv = 0;
	gt[sn - 1].pv = 0;
	for (i = 0; i < n; i++)
	{
		min = 100;
		for (j = 0; j < n; j++)
		{
			if (i==0)
			{
				if (gt[j].v == sn)
				{
					gt[j].k = 1;
					temp = al[j].next;
					while (temp != NULL)
					{
						v = (temp->v) - 1; 
						if (gt[v].dv == -1)
						{
							gt[v].dv = gt[al[j].v - 1].dv + temp->w;
							if (gt[v].dv < min)
							{
								min = gt[v].dv;
								tmin = min;
							}
							gt[v].pv = al[j].v;
						}
						temp = temp->next;
					}
					break;
				}
			}
			else if (gt[j].k == 0 && tmin==gt[j].dv)
			{
				gt[j].k = 1;
				temp = al[j].next;
				while (temp != NULL)
				{
					v = (temp->v)-1;
					if(gt[v].dv == -1 || (gt[v].k==0 && gt[v].dv>0 && gt[v].dv>(gt[al[j].v-1].dv+temp->w)))
					{
						gt[v].dv=gt[al[j].v-1].dv+temp->w;
						printf("\nV:%ld,dist: %ld", gt[v].v,gt[v].dv);
						gt[v].pv = al[j].v;
						if (gt[v].dv > tmin && min > gt[v].dv && min>tmin)
						{
							min = gt[v].dv;
						}
					}
					temp = temp->next;
				}
			}
			if (gt[j].dv > tmin && min > gt[j].dv && min>tmin)
			{
				min = gt[j].dv;
			}
			if (j == (n - 1))
			{
				tmin = min;
			}
		}
	}
}
void shortpath(gtable gt[], int n,alist al[],int sn)
{
	int sv, dv,v,dd,tv,vv;
	alist *temp = NULL;
	printf("\nEnter destination vertice: ");
	scanf_s(" %ld", &dv);
	push(dv);
	v=(int)gt[(dv - 1)].pv;
	temp = al[v - 1].next;
	while (temp != NULL)
	{
		if (temp->v == dv)
		{
			dd = temp->w;
		}
		temp = temp->next;
	}
	while(v!=dv)
	{
		push(v);
		tv = v;
		v = gt[v - 1].pv;
		if (v == 0)
		{
			break;
		}
		else
		{
			temp = al[v - 1].next;
			while (temp != NULL)
			{
				if (temp->v == tv)
				{
					dd = dd + temp->w;
					break;
				}
				temp = temp->next;
			}
		}
	}
	printf("\nPath: v%ld", pop());
	vv =pop();
	while (vv != -1)
	{
		printf("->v%ld", vv);
		vv = pop();
	}
	printf("\nShortest path from v%ld to v%ld is: %ld", sn, dv, dd);
}
void displayt(gtable gt[], int n)
{
	int i;
	printf("\nTable: ");
	for (i = 0; i < n; i++)
	{
		printf("\nv: %ld %ld %ld %ld", gt[i].v, gt[i].k, gt[i].dv, gt[i].pv);
	}
}
void main()
{
	char c = 49;
	alist *al = NULL;
	gtable *gt = NULL;
	int n, sn;
	printf("\nEnter number of vertices in the graph: ");
	scanf_s(" %ld", &n);
	al = (alist*)calloc(n, sizeof(alist));
	gt = (gtable*)calloc(n, sizeof(gtable));
	insert(al, n, gt);
	displayal(al, n);
	printf("\nEnter Starting node: ");
	scanf_s(" %ld", &sn);
	ctable(al, n, gt, sn);
	displayt(gt, n);
	while (c == 49)
	{
		shortpath(gt, n, al,sn);
		printf("\nEnter 1 for choosing another path: ");
		scanf_s(" %c", &c);
	}
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of vertices in the graph: 6

Enter vertice number: 1

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 2

Enter distance between v1 & v2: 3

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 3

Enter distance between v1 & v3: 3

Enter 1 if vertice-1 is pointing to another vertices: 2

Enter vertice number: 2

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 4

Enter distance between v2 & v4: 1

Enter 1 if vertice-2 is pointing to another vertices: 2

Enter vertice number: 3

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 6

Enter distance between v3 & v6: 4

Enter 1 if vertice-3 is pointing to another vertices: 2

Enter vertice number: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 3

Enter distance between v4 & v3: 1

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 5

Enter distance between v4 & v5: 5

Enter 1 if vertice-4 is pointing to another vertices: 2

Enter vertice number: 5

Enter 1 if vertice-5 is pointing to another vertices: 2

Enter vertice number: 6

Enter 1 if vertice-6 is pointing to another vertices: 1

Enter vertice pointed by vertice-6: 5

Enter distance between v6 & v5: 1

Enter 1 if vertice-6 is pointing to another vertices: 2

Adjancency list:
v1->v2 d: 3->v3 d: 3
v2->v4 d: 1
v3->v6 d: 4
v4->v3 d: 1->v5 d: 5
v5
v6->v5 d: 1
Enter Starting node: 1

V:4,dist: 4
V:6,dist: 7
V:5,dist: 9
V:5,dist: 8
Table:
v: 1 1 0 0
v: 2 1 3 1
v: 3 1 3 1
v: 4 1 4 2
v: 5 1 8 6
v: 6 1 7 3
Enter destination vertice: 4

Path: v1->v2->v4
Shortest path from v1 to v4 is: 4
Enter 1 for choosing another path: 1

Enter destination vertice: 2

Path: v1->v2
Shortest path from v1 to v2 is: 3
Enter 1 for choosing another path: 1

Enter destination vertice: 5

Path: v1->v3->v6->v5
Shortest path from v1 to v5 is: 8
Enter 1 for choosing another path:
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q3)

Write a program to find the minimum spanning tree of a graph using
Prims Algorithm.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct alist
{
	int v;
	int w;
	struct alist *next;
};
typedef struct alist alist;
struct gtable
{
	int k, v, dv, pv;
};
typedef struct gtable gtable;
void insert(alist al[], int n, gtable gt[])
{
	char c = 49;
	int x;
	alist *temp = NULL, *t = NULL;
	int i, flag = 0;
	for (i = 0; i < n; i++)
	{
		printf("\nEnter vertice number: ");
		scanf_s(" %ld", &al[i].v);
		al[i].w = -1;
		al[i].next = NULL;
		x = al[i].v;
		gt[i].v = x;
		printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
		scanf_s(" %c", &c);
		flag = 0;
		while (c == 49)
		{
			temp = (alist*)malloc(sizeof(alist));
			printf("\nEnter vertice pointed by vertice-%ld: ", al[i].v);
			scanf_s(" %ld", &temp->v);
			printf("\nEnter distance between v%ld & v%ld: ", al[i].v,temp->v);
			scanf_s(" %ld", &temp->w);
			temp->next = NULL;
			if (flag == 0)
			{
				al[i].next = temp;
				t = temp;
				flag = 1;
			}
			else
			{
				t->next = temp;
				t = temp;
			}
			printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
			scanf_s(" %c", &c);
		}
	}
}
void displayal(alist al[], int n)
{
	alist *t = NULL;
	printf("\nAdjancency list:");
	for (int i = 0; i < n; i++)
	{
		printf("\nv%ld", al[i].v);
		t = al[i].next;
		while (t != NULL)
		{
			printf("->v%ld d: %ld", t->v,t->w);
			t = t->next;
		}
	}
}
void ctable(alist al[], int n, gtable gt[], int sn)
{
	int i, j, v = 0,min=0,tmin=0;
	alist *temp = NULL;
	for (i = 0; i < n; i++)
	{
		gt[i].k = 0;
		gt[i].dv = -1;
		gt[i].pv = -1;
	}
	gt[sn - 1].dv = 0;
	gt[sn - 1].pv = 0;
	for (i = 0; i < n; i++)
	{
		min = 100;
		for (j = 0; j < n; j++)
		{
			if (i==0)
			{
				if (gt[j].v == sn)
				{
					gt[j].k = 1;
					temp = al[j].next;
					while (temp != NULL)
					{
						v = (temp->v) - 1; 
						if (gt[v].dv == -1)
						{
							gt[v].dv =temp->w;
							if (gt[v].dv < min)
							{
								min = gt[v].dv;
							}
							gt[v].pv = al[j].v;
						}
						temp = temp->next;
					}
					tmin = min;
					min = 100;
					j = n - 1;
					break;
				}
			}
			else if (gt[j].k == 0 && tmin==gt[j].dv)
			{
				gt[j].k = 1;
				min = 100;
				temp = al[j].next;
				while (temp != NULL)
				{
					v = (temp->v)-1;
					if(gt[v].dv == -1 || (gt[v].k==0 && gt[v].dv>0 && gt[v].dv>(temp->w)))
					{
						gt[v].dv=temp->w;
						gt[v].pv = al[j].v;
						if (min > gt[v].dv)
						{
							min = gt[v].dv;
						}
					}
					temp = temp->next;
				}
			}
			if (gt[j].k==0 && min > gt[j].dv && gt[j].dv!=-1 && gt[j].dv!=0)
			{
				min = gt[j].dv;
			}
			if (j == (n - 1))
			{
				tmin = min;
			}
		}
	}
}

void spantree(gtable gt[],int n,alist st[])
{
	alist *temp=NULL,*otemp=NULL,*ttemp=NULL;
	for (int i = 0; i < n; i++)
	{
		st[i].v=gt[i].v;
		st[i].next = NULL;
		otemp = NULL;
		temp = NULL;
		for (int j = 0; j < n; j++)
		{
			if (gt[j].pv == st[i].v)
			{
				temp=(alist*)malloc(sizeof(alist));
				temp->v=gt[j].v;
				temp->w=gt[j].dv;
				temp->next = NULL;
				if (otemp == NULL)
				{
					otemp = temp;
					st[i].next = temp;
				}
				else
				{
					otemp->next = temp;
					otemp = temp;
				}
			}
		}
	}
}

void displayt(gtable gt[], int n)
{
	int i;
	printf("\nTable: ");
	for (i = 0; i < n; i++)
	{
		printf("\nv: %ld %ld %ld %ld", gt[i].v, gt[i].k, gt[i].dv, gt[i].pv);
	}
}
void main()
{
	char c = 49;
	alist *al = NULL,*st=NULL;
	gtable *gt = NULL;
	int n, sn;
	printf("\nEnter number of vertices in the graph: ");
	scanf_s(" %ld", &n);
	al = (alist*)calloc(n, sizeof(alist));
	gt = (gtable*)calloc(n, sizeof(gtable));
	st = (alist*)calloc(n, sizeof(alist));
	insert(al, n, gt);
	displayal(al, n);
	printf("\nEnter Starting node: ");
	scanf_s(" %ld", &sn);
	ctable(al, n, gt, sn);
	displayt(gt, n);
	spantree(gt,n,st);
	printf("\nSpanning Tree: ");
	displayal(st, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of vertices in the graph: 5

Enter vertice number: 1

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 2

Enter distance between v1 & v2: 4

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 3

Enter distance between v1 & v3: 2

Enter 1 if vertice-1 is pointing to another vertices: 2

Enter vertice number: 2

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 1

Enter distance between v2 & v1: 4

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 3

Enter distance between v2 & v3: 1

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 4

Enter distance between v2 & v4: 4

Enter 1 if vertice-2 is pointing to another vertices: 2

Enter vertice number: 3

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 1

Enter distance between v3 & v1: 2

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 2

Enter distance between v3 & v2: 1

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 4

Enter distance between v3 & v4: 5

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 5

Enter distance between v3 & v5: 3

Enter 1 if vertice-3 is pointing to another vertices: 2

Enter vertice number: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 2

Enter distance between v4 & v2: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 3

Enter distance between v4 & v3: 5

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 5

Enter distance between v4 & v5: 1

Enter 1 if vertice-4 is pointing to another vertices: 2

Enter vertice number: 5

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 3

Enter distance between v5 & v3: 3

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 4

Enter distance between v5 & v4: 1

Enter 1 if vertice-5 is pointing to another vertices: 2

Adjancency list:
v1->v2 d: 4->v3 d: 2
v2->v1 d: 4->v3 d: 1->v4 d: 4
v3->v1 d: 2->v2 d: 1->v4 d: 5->v5 d: 3
v4->v2 d: 4->v3 d: 5->v5 d: 1
v5->v3 d: 3->v4 d: 1
Enter Starting node: 2

Table:
v: 1 1 2 3
v: 2 1 0 0
v: 3 1 1 2
v: 4 1 1 5
v: 5 1 3 3
Spanning Tree:
Adjancency list:
v1
v2->v3 d: 1
v3->v1 d: 2->v5 d: 3
v4
v5->v4 d: 1
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q4)

Write a program to find the minimum spanning tree of a graph using
Kruskals Algorithm.
*******************************************************************************************************************************************
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>  
typedef struct Edge
{
	int s,d,w;
}edge;
typedef struct Graph
{
	int v,e;
	edge* ed;
}graph;
typedef struct subset
{
	int parent;
	int rank;
}subset;
graph* cgraph(graph *gg,int nv,int ne)
{
	edge *ee = NULL;
	gg = (graph*)malloc(sizeof(graph));
	gg->v = nv;
	gg->e = ne;
	ee = (edge*)calloc(ne, sizeof(edge));
	for (int i = 0; i < ne; i++)
	{
		printf("\nEnter Source vertice: ");
		scanf_s(" %ld", &ee[i].s);
		printf("\nEnter Destination vertice: ");
		scanf_s(" %ld", &ee[i].d);
		printf("\nEnter Weight of Edge:- v%ld to v%ld: ", ee[i].s, ee[i].d);
		scanf_s(" %ld", &ee[i].w);
	}
	gg->ed = ee;
	return gg;
}
void displaye(edge ee[], int n)
{
	for (int i = 0; i < n; i++)
	{
		printf("\nSource: v%ld, Destination: v%ld, Weight: %ld", ee[i].s, ee[i].d, ee[i].w);
	}
}
void swap(edge *a, edge *b)
{
	edge t;
	t = *a;
	*a = *b;
	*b = t;
}
graph* sort(graph *gg)
{
	int n, i, j;
	edge *temp,*ed;
	n =gg->e;
	ed = gg->ed;
	int min;
	printf("\nBefore sorting: ");
	displaye(ed, n);
	temp = (edge*)malloc(sizeof(edge));
	for (i = 0; i < n-1; i++)
	{
		/*temp->d = ed[i].d;
		temp->s = ed[i].s;
		temp->w = ed[i].w;*/
		min = i;
		for (j = i+1; j < n; j++)
		{
			if (ed[min].w > ed[j].w)
			{
				min = j;
			}
		}
		swap(&ed[min], &ed[i]);
	}
	printf("\nAfter sorting: ");
	displaye(ed, n);
	return gg;
}
int find(subset subsets[],int i)
{
	if (subsets[i].parent!=i)
	{
		subsets[i].parent = find(subsets, subsets[i].parent);
	}
	return subsets[i].parent;
}
void Union(subset subsets[], int x, int y)
{
	int xroot = find(subsets,x);
	int yroot = find(subsets,y);
	if (subsets[xroot].rank < subsets[yroot].rank)
	{
		subsets[xroot].parent = yroot;
	}
	else if (subsets[xroot].rank > subsets[yroot].rank)
	{
		subsets[yroot].parent = xroot;
	}
	else
	{
		subsets[yroot].parent = xroot;
		subsets[xroot].rank++;
	}
}
void kruskal(graph *gg)
{
	int V = gg->v;
	int e=0,i=0;
	edge result[20],nextedge;
	gg=sort(gg);
	subset *subsets = (subset*)malloc(V * sizeof(subset));
	for (int v = 0; v < V; ++v)
	{
		subsets[v].parent = v;
		subsets[v].rank = 0;
	}
	i = 0;
	while (e<V-1 && i<gg->e)
	{
		nextedge = gg->ed[i];
		i++;
		printf("\nYo!");
		int x = find(subsets, nextedge.s);
		int y = find(subsets,nextedge.d);
		if (x != y)
		{
			result[e] = nextedge;
			e++;
			printf("\nYoy");
			Union(subsets, x, y);
		}
	}
	printf("\nSpantree: ");
	displaye(result, e);
}
void main()
{
	graph *gg=NULL; 
	int nv, ne;
	printf("\nEnter number of Vertices: ");
	scanf_s(" %ld", &nv);
	printf("\nEnter number of Edges: ");
	scanf_s(" %ld", &ne);
	gg=cgraph(gg,nv,ne);
	kruskal(gg);
	spantree(gt,n,st);
	printf("\nSpanning Tree: ");
	displayal(st, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of Vertices: 5

Enter number of Edges: 7

Enter Source vertice: 1

Enter Destination vertice: 2

Enter Weight of Edge:- v1 to v2: 4

Enter Source vertice: 1

Enter Destination vertice: 3

Enter Weight of Edge:- v1 to v3: 2

Enter Source vertice: 2

Enter Destination vertice: 3

Enter Weight of Edge:- v2 to v3: 1

Enter Source vertice: 2

Enter Destination vertice: 4

Enter Weight of Edge:- v2 to v4: 4

Enter Source vertice: 3

Enter Destination vertice: 4

Enter Weight of Edge:- v3 to v4: 5

Enter Source vertice: 3

Enter Destination vertice: 5

Enter Weight of Edge:- v3 to v5: 3

Enter Source vertice: 4

Enter Destination vertice: 5

Enter Weight of Edge:- v4 to v5: 1

Before sorting:
Source: v1, Destination: v2, Weight: 4
Source: v1, Destination: v3, Weight: 2
Source: v2, Destination: v3, Weight: 1
Source: v2, Destination: v4, Weight: 4
Source: v3, Destination: v4, Weight: 5
Source: v3, Destination: v5, Weight: 3
Source: v4, Destination: v5, Weight: 1
After sorting:
Source: v2, Destination: v3, Weight: 1
Source: v4, Destination: v5, Weight: 1
Source: v1, Destination: v3, Weight: 2
Source: v3, Destination: v5, Weight: 3
Source: v2, Destination: v4, Weight: 4
Source: v1, Destination: v2, Weight: 4
Source: v3, Destination: v4, Weight: 5
Spanning Tree:
Adjancency list:
v1
v2->v3 d: 1
v3->v1 d: 2->v5 d: 3
v4
v5->v4 d: 1
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q5)

Write a program to perform Breadth-First Traversal on a graph.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct alist
{
	int v;
	int w;
	int l;
	struct alist *next;
};
typedef struct alist alist;
struct gtable
{
	int k, v, dv, pv;
};
typedef struct gtable gtable;
void insert(alist al[], int n, gtable gt[])
{
	char c = 49;
	int x;
	alist *temp = NULL, *t = NULL;
	int i, flag = 0;
	for (i = 0; i < n; i++)
	{
		printf("\nEnter vertice number: ");
		scanf_s(" %ld", &al[i].v);
		printf("\nEnter level of vertice-%ld", al[i].v);
		scanf_s(" %ld", &al[i].l);
		al[i].w = -1;
		al[i].next = NULL;
		x = al[i].v;
		gt[i].v = x;
		printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
		scanf_s(" %c", &c);
		flag = 0;
		while (c == 49)
		{
			temp = (alist*)malloc(sizeof(alist));
			printf("\nEnter vertice pointed by vertice-%ld: ", al[i].v);
			scanf_s(" %ld", &temp->v);
			printf("\nEnter distance between v%ld & v%ld: ", al[i].v,temp->v);
			scanf_s(" %ld", &temp->w);
			temp->next = NULL;
			if (flag == 0)
			{
				al[i].next = temp;
				t = temp;
				flag = 1;
			}
			else
			{
				t->next = temp;
				t = temp;
			}
			printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
			scanf_s(" %c", &c);
		}
	}
}
void displayal(alist al[], int n)
{
	alist *t = NULL;
	printf("\nAdjancency list:");
	for (int i = 0; i < n; i++)
	{
		printf("\nv%ld", al[i].v);
		t = al[i].next;
		while (t != NULL)
		{
			printf("->v%ld d: %ld", t->v,t->w);
			t = t->next;
		}
	}
}
//void ctable(alist al[], int n, gtable gt[], int sn)
//{
//	int i, j, v = 0,min=0,tmin=0;
//	alist *temp = NULL;
//	for (i = 0; i < n; i++)
//	{
//		gt[i].k = 0;
//		gt[i].dv = -1;
//		gt[i].pv = -1;
//	}
//	gt[sn - 1].dv = 0;
//	gt[sn - 1].pv = 0;
//	for (i = 0; i < n; i++)
//	{
//		min = 100;
//		for (j = 0; j < n; j++)
//		{
//			if (i==0)
//			{
//				if (gt[j].v == sn)
//				{
//					gt[j].k = 1;
//					temp = al[j].next;
//					while (temp != NULL)
//					{
//						v = (temp->v) - 1; 
//						if (gt[v].dv == -1)
//						{
//							gt[v].dv =temp->w;
//							if (gt[v].dv < min)
//							{
//								min = gt[v].dv;
//							}
//							gt[v].pv = al[j].v;
//						}
//						temp = temp->next;
//					}
//					tmin = min;
//					min = 100;
//					j = n - 1;
//					break;
//				}
//			}
//			else if (gt[j].k == 0 && tmin==gt[j].dv)
//			{
//				gt[j].k = 1;
//				min = 100;
//				temp = al[j].next;
//				while (temp != NULL)
//				{
//					v = (temp->v)-1;
//					if(gt[v].dv == -1 || (gt[v].k==0 && gt[v].dv>0 && gt[v].dv>(temp->w)))
//					{
//						gt[v].dv=temp->w;
//						gt[v].pv = al[j].v;
//						if (min > gt[v].dv)
//						{
//							min = gt[v].dv;
//						}
//					}
//					temp = temp->next;
//				}
//			}
//			if (gt[j].k==0 && min > gt[j].dv && gt[j].dv!=-1 && gt[j].dv!=0)
//			{
//				min = gt[j].dv;
//			}
//			if (j == (n - 1))
//			{
//				tmin = min;
//			}
//		}
//	}
//}
int front = -1, rear = -1,a[20];
void push(int n)
{
	if (rear == -1)
	{
		rear = front = 0;
	}
	else
	{
		rear++;
	}
	a[rear] = n;
}
int pop(alist al[],int n,gtable gt[])
{
	int v,i;
	alist *temp = NULL;
	if (front ==-1)
	{
		v = -1;
	}
	else
	{
		v = a[front];
		if (front == rear)
		{
			front=rear = -1;
		}
		else
		{
			front++;
		}
		temp = al[v - 1].next;
		while (temp != NULL)
		{
			if (gt[(temp->v) - 1].k != 1)
			{
				gt[(temp->v) - 1].k = 1;
				push(temp->v);
			}
			temp = temp->next;
		}
	}
	return v;
}
void ctable(alist al[], int n, gtable gt[], int sn,int ln)
{
	int i, j, v = 0, min = 0, tmin = 0;
	alist *temp = NULL;
	printf("\nBFS Traversal:-	");
	for (i = 1; i <= ln; i++)
	{
		for (j = 0; j < n; j++)
		{
			if (al[j].l == i && gt[j].k!=1)
			{
				gt[j].k = 1;
				push(al[j].v);
			}
		}
		int q = 0;
		while (q != -1)
		{
			q = pop(al, n, gt);
			if (q != -1)
			{
				printf(" v%ld ->", q);
			}
			else
			{
				break;
			}
		}
	}
}

void displayt(gtable gt[], int n)
{
	int i;
	printf("\nTable: ");
	for (i = 0; i < n; i++)
	{
		printf("\nv: %ld %ld %ld %ld", gt[i].v, gt[i].k, gt[i].dv, gt[i].pv);
	}
}
void main()
{
	char c = 49;
	alist *al = NULL,*st=NULL;
	gtable *gt = NULL;
	int n, sn,ln;
	printf("\nEnter number of vertices in the graph: ");
	scanf_s(" %ld", &n);
	printf("\nEnter number of levels in the graph: ");
	scanf_s(" %ld", &ln);
	al = (alist*)calloc(n, sizeof(alist));
	gt = (gtable*)calloc(n, sizeof(gtable));
	st = (alist*)calloc(n, sizeof(alist));
	insert(al, n, gt);
	displayal(al, n);
	printf("\nEnter Starting node: ");
	scanf_s(" %ld", &sn);
	ctable(al, n, gt, sn,ln);
	//displayt(gt, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of vertices in the graph: 5

Enter number of levels in the graph: 3

Enter vertice number: 1

Enter level of vertice-11

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 2

Enter distance between v1 & v2: 4

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 3

Enter distance between v1 & v3: 2

Enter 1 if vertice-1 is pointing to another vertices: 2

Enter vertice number: 2

Enter level of vertice-21

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 1

Enter distance between v2 & v1: 4

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 3

Enter distance between v2 & v3: 1

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 4

Enter distance between v2 & v4: 4

Enter 1 if vertice-2 is pointing to another vertices: 2

Enter vertice number: 3

Enter level of vertice-32

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 1

Enter distance between v3 & v1: 2

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 2

Enter distance between v3 & v2: 1

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 4

Enter distance between v3 & v4: 5

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 5

Enter distance between v3 & v5: 3

Enter 1 if vertice-3 is pointing to another vertices: 2

Enter vertice number: 4

Enter level of vertice-42

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 2

Enter distance between v4 & v2: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 3

Enter distance between v4 & v3: 3

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 5

Enter distance between v4 & v5: 1

Enter 1 if vertice-4 is pointing to another vertices: 2

Enter vertice number: 5

Enter level of vertice-53

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 3

Enter distance between v5 & v3: 3

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 4

Enter distance between v5 & v4: 1

Enter 1 if vertice-5 is pointing to another vertices: 2

Adjancency list:
v1->v2 d: 4->v3 d: 2
v2->v1 d: 4->v3 d: 1->v4 d: 4
v3->v1 d: 2->v2 d: 1->v4 d: 5->v5 d: 3
v4->v2 d: 4->v3 d: 3->v5 d: 1
v5->v3 d: 3->v4 d: 1
Enter Starting node: 2

BFS Traversal:-  v1 -> v2 -> v3 -> v4 -> v5
*******************************************************************************************************************************************
*******************************************************************************************************************************************
Q6)

Write a program to perform Depth-First Traversal on a graph.
*******************************************************************************************************************************************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct alist
{
	int v;
	int w;
	int l;
	struct alist *next;
};
typedef struct alist alist;
struct gtable
{
	int k, v, dv, pv;
};
typedef struct gtable gtable;
void insert(alist al[], int n, gtable gt[])
{
	char c = 49;
	int x;
	alist *temp = NULL, *t = NULL;
	int i, flag = 0;
	for (i = 0; i < n; i++)
	{
		printf("\nEnter vertice number: ");
		scanf_s(" %ld", &al[i].v);/*
		printf("\nEnter level of vertice-%ld", al[i].v);
		scanf_s(" %ld", &al[i].l);*/
		al[i].w = -1;
		al[i].next = NULL;
		x = al[i].v;
		gt[i].v = x;
		printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
		scanf_s(" %c", &c);
		flag = 0;
		while (c == 49)
		{
			temp = (alist*)malloc(sizeof(alist));
			printf("\nEnter vertice pointed by vertice-%ld: ", al[i].v);
			scanf_s(" %ld", &temp->v);/*
			printf("\nEnter distance between v%ld & v%ld: ", al[i].v, temp->v);
			scanf_s(" %ld", &temp->w);*/
			temp->next = NULL;
			if (flag == 0)
			{
				al[i].next = temp;
				t = temp;
				flag = 1;
			}
			else
			{
				t->next = temp;
				t = temp;
			}
			printf("\nEnter 1 if vertice-%ld is pointing to another vertices: ", al[i].v);
			scanf_s(" %c", &c);
		}
	}
}
void displayal(alist al[], int n)
{
	alist *t = NULL;
	printf("\nAdjancency list:");
	for (int i = 0; i < n; i++)
	{
		printf("\nv%ld", al[i].v);
		t = al[i].next;
		while (t != NULL)
		{
			printf("->v%ld", t->v);
			t = t->next;
		}
	}
}
//void ctable(alist al[], int n, gtable gt[], int sn)
//{
//	int i, j, v = 0,min=0,tmin=0;
//	alist *temp = NULL;
//	for (i = 0; i < n; i++)
//	{
//		gt[i].k = 0;
//		gt[i].dv = -1;
//		gt[i].pv = -1;
//	}
//	gt[sn - 1].dv = 0;
//	gt[sn - 1].pv = 0;
//	for (i = 0; i < n; i++)
//	{
//		min = 100;
//		for (j = 0; j < n; j++)
//		{
//			if (i==0)
//			{
//				if (gt[j].v == sn)
//				{
//					gt[j].k = 1;
//					temp = al[j].next;
//					while (temp != NULL)
//					{
//						v = (temp->v) - 1; 
//						if (gt[v].dv == -1)
//						{
//							gt[v].dv =temp->w;
//							if (gt[v].dv < min)
//							{
//								min = gt[v].dv;
//							}
//							gt[v].pv = al[j].v;
//						}
//						temp = temp->next;
//					}
//					tmin = min;
//					min = 100;
//					j = n - 1;
//					break;
//				}
//			}
//			else if (gt[j].k == 0 && tmin==gt[j].dv)
//			{
//				gt[j].k = 1;
//				min = 100;
//				temp = al[j].next;
//				while (temp != NULL)
//				{
//					v = (temp->v)-1;
//					if(gt[v].dv == -1 || (gt[v].k==0 && gt[v].dv>0 && gt[v].dv>(temp->w)))
//					{
//						gt[v].dv=temp->w;
//						gt[v].pv = al[j].v;
//						if (min > gt[v].dv)
//						{
//							min = gt[v].dv;
//						}
//					}
//					temp = temp->next;
//				}
//			}
//			if (gt[j].k==0 && min > gt[j].dv && gt[j].dv!=-1 && gt[j].dv!=0)
//			{
//				min = gt[j].dv;
//			}
//			if (j == (n - 1))
//			{
//				tmin = min;
//			}
//		}
//	}
//}
int top = -1;
alist *a[20] = { NULL };
void push(alist *temp,gtable gt[],int n,alist al[])
{
	alist *t = NULL;
	top++;
	if (temp!=NULL && gt[(temp->v)-1].k==0)
	{
		a[top] = temp;
		gt[(temp->v) - 1].k = 1;
		printf("v%ld->", temp->v);
		push(al[(temp->v)-1].next, gt, n,al);
	}
	else if (temp!=NULL && gt[(temp->v) - 1].k == 1)
	{
		temp = temp->next;
		if (temp != NULL)
		{
			push(temp, gt, n,al);
		}
	}
}
int pop(alist al[], int n, gtable gt[])
{
	int i,v;
	alist *temp = NULL;
	if (top == -1)
	{
		v=-1;
	}
	else
	{
		v = top;
		top--;
	}
	return v;
}
void ctable(alist al[], int n, gtable gt[], int sn)
{
	int i, j, v = 0, min = 0, tmin = 0;
	alist *temp = NULL;
	for (i = 0; i < n; i++)
	{
		gt[i].k = 0;
	}
	printf("\nDFS Traversal:-	");
		for (j = 0; j < n; j++)
		{
			if (al[j].v == sn)
			{
				push(&al[j], gt, n,al);
				while (v != -1)
				{
					v = pop(al, n, gt);
				}
				break;
			}
		}
}

void displayt(gtable gt[], int n)
{
	int i;
	printf("\nTable: ");
	for (i = 0; i < n; i++)
	{
		printf("\nv: %ld %ld %ld %ld", gt[i].v, gt[i].k, gt[i].dv, gt[i].pv);
	}
}
void main()
{
	char c = 49;
	alist *al = NULL, *st = NULL;
	gtable *gt = NULL;
	int n, sn;
	printf("\nEnter number of vertices in the graph: ");
	scanf_s(" %ld", &n);
	al = (alist*)calloc(n, sizeof(alist));
	gt = (gtable*)calloc(n, sizeof(gtable));
	st = (alist*)calloc(n, sizeof(alist));
	insert(al, n, gt);
	displayal(al, n);
	printf("\nEnter Starting node: ");
	scanf_s(" %ld", &sn);
	ctable(al, n, gt, sn);
	//displayt(gt, n);
	_getch();
}
*******************************************************************************************************************************************
								OUTPUT
*******************************************************************************************************************************************

Enter number of vertices in the graph: 5

Enter vertice number: 1

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 2

Enter 1 if vertice-1 is pointing to another vertices: 1

Enter vertice pointed by vertice-1: 3

Enter 1 if vertice-1 is pointing to another vertices: 2

Enter vertice number: 2

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 1

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 3

Enter 1 if vertice-2 is pointing to another vertices: 1

Enter vertice pointed by vertice-2: 4

Enter 1 if vertice-2 is pointing to another vertices: 2

Enter vertice number: 3

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 1

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 2

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 4

Enter 1 if vertice-3 is pointing to another vertices: 1

Enter vertice pointed by vertice-3: 5

Enter 1 if vertice-3 is pointing to another vertices: 2

Enter vertice number: 4

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 2

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 3

Enter 1 if vertice-4 is pointing to another vertices: 1

Enter vertice pointed by vertice-4: 5

Enter 1 if vertice-4 is pointing to another vertices: 2

Enter vertice number: 5

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 3

Enter 1 if vertice-5 is pointing to another vertices: 1

Enter vertice pointed by vertice-5: 4

Enter 1 if vertice-5 is pointing to another vertices: 2

Adjancency list:
v1->v2->v3
v2->v1->v3->v4
v3->v1->v2->v4->v5
v4->v2->v3->v5
v5->v3->v4
Enter Starting node: 2

DFS Traversal:- v2->v1->v3->v4->v5
*******************************************************************************************************************************************
*******************************************************************************************************************************************